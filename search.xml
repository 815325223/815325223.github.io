<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[proxmox中cloud-init使用方法]]></title>
    <url>%2F2019%2F04%2F18%2Fproxmox%E4%B8%ADcloud-init%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模版制作标准分区ext4，不添加swap分区，原因下文说。 系统装完后，将网卡配置文件内的onboot打开，清除uuid。关闭selinux和firewalld以及碍事的NetworkManager。123systemctl disable --now firewalld NetworkManagersetenforce 0sed -ri '/^[^#]*SELINUX=/s#=.+$#=disabled#' /etc/selinux/config]]></content>
      <categories>
        <category>Proxmox</category>
      </categories>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubernetes应用快速入门]]></title>
    <url>%2F2019%2F04%2F16%2Fubernetes%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[kubectl是api-server的客户端工具，可以连接至它，实现对kubernetes相关对象资源的增删改查等基本操作。 基本对象：pod, service, replicaSet, deployment, statefulSet, daemonSet, job, cronjob, node 查看集群信息1$ kubectl cluster-info 查看节点的详细信息1$ kubectl describe node k8s-node01 查看客户端和服务器侧的版本信息1$ kubectl version 命令行启动Pod控制器123456789101112$ kubectl run nginx-deploy --image=nginx:1.14-alpine --port=80 --replicas=1$ kubectl get deploymentNAME DESIRED(期望) CURRENT(目前) UP-TO-DATE(最新状态) AVAILABLE(就绪性探测) AGEnginx-deploy 1 1 1 1 19s$ kubectl get pods -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEnginx-deploy-86bf78c77-xss6n 1/1 Running 0 7m16s 10.244.1.2 k8s-node01 &lt;none&gt;$ curl 10.244.1.2 (供集群内部访问)&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt; 因为Pod控制器，删除的Pod又会重新被创建1234567891011$ kubectl get podsNAME READY STATUS RESTARTS AGEnginx-deploy-86bf78c77-xss6n 1/1 Running 0 48m$ kubectl delete pod nginx-deploy-86bf78c77-xss6npod "nginx-deploy-86bf78c77-xss6n" deleted$ kubectl get podsNAME READY STATUS RESTARTS AGEnginx-deploy-86bf78c77-xpddl 0/1 ContainerCreating 0 4s$ kubectl get pods -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEnginx-deploy-86bf78c77-xpddl 1/1 Running 0 86s 10.244.2.2 k8s-node02 &lt;none&gt; 创建固定访问端点service，通过标签选择器绑定了Pod，就算Pod重建，仍然可以访问；宿主机不能解析是因为搜索域的问题。默认类型ClusterIP，只拥有一个service IP，只能在集群内被各Pod客户端访问，而不能突破集群边界，被集群外部的客户端访问。123456789101112131415161718192021222324252627282930313233343536$ kubectl expose --name=nginx deployment nginx-deploy --port=80 --target-port=80 --protocol=TCPservice/nginx exposed$ kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 16dnginx ClusterIP 10.111.72.29 &lt;none&gt; 80/TCP 34s$ $ kubectl run client --image=busybox --rm -it sh/ # cat /etc/resolv.conf nameserver 10.96.0.10search default.svc.cluster.local svc.cluster.local cluster.localoptions ndots:5/ # wget -O - -q http://nginx:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;$ dig -t A nginx.default.svc.cluster.local @10.96.0.10 ; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-72.el7 &lt;&lt;&gt;&gt; -t A nginx.default.svc.cluster.local @10.96.0.10;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 12874;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;nginx.default.svc.cluster.local. IN A ;; ANSWER SECTION:nginx.default.svc.cluster.local. 5 IN A 10.111.72.29 ;; Query time: 0 msec;; SERVER: 10.96.0.10#53(10.96.0.10);; WHEN: Thu Jan 24 22:06:20 CST 2019;; MSG SIZE rcvd: 107 service根据pod的标签进行绑定12345678910111213141516171819202122232425262728293031$ kubectl describe svc nginxName: nginxNamespace: defaultLabels: run=nginx-deployAnnotations: &lt;none&gt;Selector: run=nginx-deployType: ClusterIPIP: 10.111.72.29Port: &lt;unset&gt; 80/TCPTargetPort: 80/TCPEndpoints: 10.244.2.2:80Session Affinity: NoneEvents: &lt;none&gt;$ kubectl delete pod nginx-deploy-86bf78c77-xpddlpod "nginx-deploy-86bf78c77-xpddl" deleted$ kubectl describe svc nginxName: nginxNamespace: defaultLabels: run=nginx-deployAnnotations: &lt;none&gt;Selector: run=nginx-deployType: ClusterIPIP: 10.111.72.29Port: &lt;unset&gt; 80/TCPTargetPort: 80/TCPEndpoints: 10.244.1.5:80Session Affinity: NoneEvents: &lt;none&gt;$ kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELSnginx-deploy-86bf78c77-mb82b 1/1 Running 0 56s pod-template-hash=86bf78c77,run=nginx-deploy service信息可以动态反映到CoreDNS内123456789$ kubectl delete svc nginxservice "nginx" deleted$ kubectl expose deployment nginx-deploy --name=nginx --port=80 --target-port=80 --protocol=TCPservice/nginx exposed/ # wget -O - -q http://nginx:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt; service负载均衡，手动扩缩容Pod数量12345678910111213141516171819202122232425262728293031$ kubectl run myapp --image=ikubernetes/myapp:v1 --replicas=2/ # wget -O - -q 10.244.1.6/hostname.htmlmyapp-6946649ccd-6d495/ # wget -O - -q 10.244.2.3/hostname.htmlmyapp-6946649ccd-tsnjf$ kubectl expose deployment myapp --name=myapp --port=80service/myapp exposed/ # wget -O - -q myapp/hostname.htmlmyapp-6946649ccd-tsnjf/ # while true; do wget -O - -q myapp/hostname.html; sleep 1; donemyapp-6946649ccd-6d495myapp-6946649ccd-tsnjfmyapp-6946649ccd-tsnjfmyapp-6946649ccd-6d495myapp-6946649ccd-tsnjfmyapp-6946649ccd-tsnjfmyapp-6946649ccd-tsnjf$ kubectl scale --replicas=5 deployment myappdeployment.extensions/myapp scaled/ # while true; do wget -O - -q myapp/hostname.html; sleep 1; donemyapp-6946649ccd-6d495myapp-6946649ccd-4mtsvmyapp-6946649ccd-j2t28myapp-6946649ccd-6d495myapp-6946649ccd-j2t28myapp-6946649ccd-j2t28myapp-6946649ccd-6d495myapp-6946649ccd-tsnjfmyapp-6946649ccd-6d495$ kubectl scale --replicas=3 deployment myappdeployment.extensions/myapp scaled 灰度发布，更新与回滚12345678910111213141516171819202122232425262728293031323334353637383940414243$ kubectl set image deployment myapp myapp=ikubernetes/myapp:v2deployment.extensions/myapp image updated$ kubectl rollout status deployment myappWaiting for deployment "myapp" rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment "myapp" rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment "myapp" rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment "myapp" rollout to finish: 2 out of 3 new replicas have been updated...Waiting for deployment "myapp" rollout to finish: 2 out of 3 new replicas have been updated...Waiting for deployment "myapp" rollout to finish: 2 old replicas are pending termination...Waiting for deployment "myapp" rollout to finish: 1 old replicas are pending termination...Waiting for deployment "myapp" rollout to finish: 1 old replicas are pending termination...deployment "myapp" successfully rolled out/ # while true; do wget -O - -q myapp; sleep 1; doneHello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href="hostname.html"&gt;Pod Name&lt;/a&gt;$ kubectl rollout undo deployment myappdeployment.extensions/myapp 节点上相应iptables规则1# iptables -vnL -t nat 使集群外部可以访问myapp12345$ kubectl edit svc myapptype: ClusterIP --&gt; type: NodePort$ kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEmyapp NodePort 10.102.196.200 &lt;none&gt; 80:32074/TCP 14m PS: 如果节点宕机，还可以通过其它节点访问。外部做负载均衡器，例如keepalived，指向到每一个节点。Nginx或者haproxy，拥有后端realserver的健康度检查，并且需要配置HA高可用。]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[k8s配置secret拉取私有仓库镜像]]></title>
    <url>%2F2019%2F04%2F10%2Fk8s%E9%85%8D%E7%BD%AEsecret%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[https://kubernetes.io/docs 样例123456789101112import os# cat ~/.docker/config.json &#123; "auths": &#123; "harbor.station.com": &#123; "auth": "YWRtaW46SGFyYm9yMTIzNDU=" &#125; &#125;, "HttpHeaders": &#123; "User-Agent": "Docker-Client/18.06.1-ce (linux)" &#125;&#125; 这个时候我们虽然可以通过交互式登录，使用docker pull拉取镜像，但无法通过k8s创建Pod时拉取镜像。 生成密钥secret1# kubectl create secret docker-registry harbor --docker-server=x.x.x.x --docker-username=admin --docker-password=Harbor12345 --docker-email=xx@qq.com 1) harbor: 指定密钥的键名称，可自行定义 2）–docker-server：指定docker仓库地址 3）–docker-username：指定docker仓库帐号 4) –docker-password：指定docker仓库密码 5) –docker-email：指定邮件地址（选填）` 查看密钥可以看到当前除了默认的密钥, 还有我们刚才生成的. 另外要注意的是, 该密钥只能在对应namespace使用, 也就是这里的default, 如果需要用到其他namespace, 比如说test, 就需要在生成的时候指定参数 -n test。1234# kubectl get secretsNAME TYPE DATA AGEdefault-token-mzmtj kubernetes.io/service-account-token 3 22mharbor kubernetes.io/dockerconfigjson 1 22m YAML例子其中imagePullSecrets是声明拉取镜像时需要指定密钥, harbor必须和上面生成密钥的键名一致, 另外检查一下pod和密钥是否在同一个namespace, 之后k8s便可以拉取镜像。1234567891011121314151617apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: nginx-deploy namespace: harborspec: replicas: 3 template: metadata: labels: app: web_server spec: containers: - name: nginx image: harbor.station.com/library/nginx:latest imagePullSecrets: - name: harbor]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Harbor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
