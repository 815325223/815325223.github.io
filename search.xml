<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[proxmox中cloud-init使用方法]]></title>
    <url>%2F2019%2F04%2F18%2Fproxmox%E4%B8%ADcloud-init%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模版制作标准分区ext4，不添加swap分区，原因下文说。 系统装完后，将网卡配置文件内的onboot打开，清除uuid。关闭selinux和firewalld以及碍事的NetworkManager。123systemctl disable --now firewalld NetworkManagersetenforce 0sed -ri '/^[^#]*SELINUX=/s#=.+$#=disabled#' /etc/selinux/config 为了让虚拟化层可以重启和关闭虚拟机，必须安装acpid服务；为了使根分区正确调整大小安装cloud-utils-growpart，cloud-init支持下发前设置信息写入。12yum install -y acpid cloud-init cloud-utils-growpartsystemctl enable acpid 禁用默认zeroconf路线1echo "NOZEROCONF=yes" &gt;&gt; /etc/sysconfig/network 防止ssh连接使用dns导致访问过慢12sed -ri '/UseDNS/&#123;s@#@@;s@\s+.+@ no@&#125;' /etc/ssh/sshd_configsystemctl restart sshd cloud-init配置文件:1. ssh_pwauth 为 0 是禁止使用password登陆。2. disable_root：1 是禁止root登陆。3. package-update-upgrade-install会在第一次开机启动时自动yum update -y。123sed -ri '/disable_root/&#123;s#\S$#0#&#125;' /etc/cloud/cloud.cfgsed -ri '/ssh_pwauth/&#123;s#\S$#1#&#125;' /etc/cloud/cloud.cfgsed -ri '/package-update/s@^@#@' /etc/cloud/cloud.cfg 默认cloud-init会创建一个系统类型的用户,可以注释掉。1234567# default_user:# name: centos# lock_passwd: true# gecos: Cloud User# groups: [wheel, adm, systemd-journal]# sudo: ["ALL=(ALL) NOPASSWD:ALL"]# shell: /bin/bash 安装些基础包和预设一些脚本的话就可以关机。12yum install vim git wget -ypoweroff 转换模版12345678root@pve:~# qm list VMID NAME STATUS MEM(MB) BOOTDISK(GB) PID 100 cloud-init stopped 2048 20.00 0 101 k8s-m1 running 2048 20.00 7438root@pve:~# qm set 100 --ide2 local-lvm:cloudinitupdate VM 100: -ide2 local-lvm:cloudinit Using default stripesize 64.00 KiB. Logical volume "vm-100-cloudinit" created. 在Dashboard上可以看到虚拟机的could-init部分已经可以更改属性了。 在Dashboard上把它转换成模板,部署时完整克隆,开机之前双击需要设置的信息即可,否则例如密码不设置默认是模板的密码。也可以通过命令行初始化虚拟机信息。1qm set &lt;vmid&gt; --ipconfig0 ip=10.105.26.x/23,gw=10.105.26.1 备份和恢复虚拟机123456789101112131415161718192021222324252627282930313233root@pve:~# vzdump 100INFO: starting new backup job: vzdump 100INFO: Starting Backup of VM 100 (qemu)INFO: status = stoppedINFO: update VM 100: -lock backupINFO: backup mode: stopINFO: ionice priority: 7INFO: VM Name: cloud-initINFO: include disk 'scsi0' 'local-lvm:vm-100-disk-0' 20GINFO: creating archive '/var/lib/vz/dump/vzdump-qemu-100-2019_04_18-12_48_38.vma'INFO: starting kvm to execute backup taskTotal translation table size: 0Total rockridge attributes bytes: 417Total directory bytes: 0Path table size(bytes): 10Max brk space used 0178 extents written (0 MB)INFO: started backup task 'd65a8f26-20fe-4232-abd3-ec0bcf4623cd'INFO: status: 3% (785645568/21474836480), sparse 1% (395206656), duration 3, read/write 261/130 MB/sINFO: status: 21% (4593876992/21474836480), sparse 19% (4184059904), duration 6, read/write 1269/6 MB/sINFO: status: 34% (7457996800/21474836480), sparse 32% (6929133568), duration 9, read/write 954/39 MB/sINFO: status: 50% (10746396672/21474836480), sparse 46% (10083291136), duration 12, read/write 1096/44 MB/sINFO: status: 61% (13169524736/21474836480), sparse 57% (12349382656), duration 15, read/write 807/52 MB/sINFO: status: 70% (15039004672/21474836480), sparse 64% (13956280320), duration 18, read/write 623/87 MB/sINFO: status: 80% (17196580864/21474836480), sparse 74% (15934279680), duration 21, read/write 719/59 MB/sINFO: status: 89% (19120455680/21474836480), sparse 82% (17667883008), duration 24, read/write 641/63 MB/sINFO: status: 95% (20594622464/21474836480), sparse 88% (18997477376), duration 27, read/write 491/48 MB/sINFO: status: 100% (21474836480/21474836480), sparse 92% (19877691392), duration 28, read/write 880/0 MB/sINFO: transferred 21474 MB in 28 seconds (766 MB/s)INFO: stopping kvm after backup taskINFO: archive file size: 1.49GBINFO: Finished Backup of VM 100 (00:00:32)INFO: Backup job finished 输出路径在：/var/lib/vz/dump/，导入的话使用如下命令1qmrestore vzdump-qemu-xx.vma &lt;vmid&gt;]]></content>
      <categories>
        <category>Proxmox</category>
      </categories>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubernetes应用快速入门]]></title>
    <url>%2F2019%2F04%2F16%2Fubernetes%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[kubectl是api-server的客户端工具，可以连接至它，实现对kubernetes相关对象资源的增删改查等基本操作。 基本对象：pod, service, replicaSet, deployment, statefulSet, daemonSet, job, cronjob, node 查看集群信息1$ kubectl cluster-info 查看节点的详细信息1$ kubectl describe node k8s-node01 查看客户端和服务器侧的版本信息1$ kubectl version 命令行启动Pod控制器123456789101112$ kubectl run nginx-deploy --image=nginx:1.14-alpine --port=80 --replicas=1$ kubectl get deploymentNAME DESIRED(期望) CURRENT(目前) UP-TO-DATE(最新状态) AVAILABLE(就绪性探测) AGEnginx-deploy 1 1 1 1 19s$ kubectl get pods -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEnginx-deploy-86bf78c77-xss6n 1/1 Running 0 7m16s 10.244.1.2 k8s-node01 &lt;none&gt;$ curl 10.244.1.2 (供集群内部访问)&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt; 因为Pod控制器，删除的Pod又会重新被创建1234567891011$ kubectl get podsNAME READY STATUS RESTARTS AGEnginx-deploy-86bf78c77-xss6n 1/1 Running 0 48m$ kubectl delete pod nginx-deploy-86bf78c77-xss6npod &quot;nginx-deploy-86bf78c77-xss6n&quot; deleted$ kubectl get podsNAME READY STATUS RESTARTS AGEnginx-deploy-86bf78c77-xpddl 0/1 ContainerCreating 0 4s$ kubectl get pods -owideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEnginx-deploy-86bf78c77-xpddl 1/1 Running 0 86s 10.244.2.2 k8s-node02 &lt;none&gt; 创建固定访问端点service，通过标签选择器绑定了Pod，就算Pod重建，仍然可以访问；宿主机不能解析是因为搜索域的问题。默认类型ClusterIP，只拥有一个service IP，只能在集群内被各Pod客户端访问，而不能突破集群边界，被集群外部的客户端访问。123456789101112131415161718192021222324252627282930313233343536$ kubectl expose --name=nginx deployment nginx-deploy --port=80 --target-port=80 --protocol=TCPservice/nginx exposed$ kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 16dnginx ClusterIP 10.111.72.29 &lt;none&gt; 80/TCP 34s$ $ kubectl run client --image=busybox --rm -it sh/ # cat /etc/resolv.conf nameserver 10.96.0.10search default.svc.cluster.local svc.cluster.local cluster.localoptions ndots:5/ # wget -O - -q http://nginx:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;$ dig -t A nginx.default.svc.cluster.local @10.96.0.10 ; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-72.el7 &lt;&lt;&gt;&gt; -t A nginx.default.svc.cluster.local @10.96.0.10;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 12874;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;nginx.default.svc.cluster.local. IN A ;; ANSWER SECTION:nginx.default.svc.cluster.local. 5 IN A 10.111.72.29 ;; Query time: 0 msec;; SERVER: 10.96.0.10#53(10.96.0.10);; WHEN: Thu Jan 24 22:06:20 CST 2019;; MSG SIZE rcvd: 107 service根据pod的标签进行绑定12345678910111213141516171819202122232425262728293031$ kubectl describe svc nginxName: nginxNamespace: defaultLabels: run=nginx-deployAnnotations: &lt;none&gt;Selector: run=nginx-deployType: ClusterIPIP: 10.111.72.29Port: &lt;unset&gt; 80/TCPTargetPort: 80/TCPEndpoints: 10.244.2.2:80Session Affinity: NoneEvents: &lt;none&gt;$ kubectl delete pod nginx-deploy-86bf78c77-xpddlpod &quot;nginx-deploy-86bf78c77-xpddl&quot; deleted$ kubectl describe svc nginxName: nginxNamespace: defaultLabels: run=nginx-deployAnnotations: &lt;none&gt;Selector: run=nginx-deployType: ClusterIPIP: 10.111.72.29Port: &lt;unset&gt; 80/TCPTargetPort: 80/TCPEndpoints: 10.244.1.5:80Session Affinity: NoneEvents: &lt;none&gt;$ kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELSnginx-deploy-86bf78c77-mb82b 1/1 Running 0 56s pod-template-hash=86bf78c77,run=nginx-deploy service信息可以动态反映到CoreDNS内123456789$ kubectl delete svc nginxservice &quot;nginx&quot; deleted$ kubectl expose deployment nginx-deploy --name=nginx --port=80 --target-port=80 --protocol=TCPservice/nginx exposed/ # wget -O - -q http://nginx:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt; service负载均衡，手动扩缩容Pod数量12345678910111213141516171819202122232425262728293031$ kubectl run myapp --image=ikubernetes/myapp:v1 --replicas=2/ # wget -O - -q 10.244.1.6/hostname.htmlmyapp-6946649ccd-6d495/ # wget -O - -q 10.244.2.3/hostname.htmlmyapp-6946649ccd-tsnjf$ kubectl expose deployment myapp --name=myapp --port=80service/myapp exposed/ # wget -O - -q myapp/hostname.htmlmyapp-6946649ccd-tsnjf/ # while true; do wget -O - -q myapp/hostname.html; sleep 1; donemyapp-6946649ccd-6d495myapp-6946649ccd-tsnjfmyapp-6946649ccd-tsnjfmyapp-6946649ccd-6d495myapp-6946649ccd-tsnjfmyapp-6946649ccd-tsnjfmyapp-6946649ccd-tsnjf$ kubectl scale --replicas=5 deployment myappdeployment.extensions/myapp scaled/ # while true; do wget -O - -q myapp/hostname.html; sleep 1; donemyapp-6946649ccd-6d495myapp-6946649ccd-4mtsvmyapp-6946649ccd-j2t28myapp-6946649ccd-6d495myapp-6946649ccd-j2t28myapp-6946649ccd-j2t28myapp-6946649ccd-6d495myapp-6946649ccd-tsnjfmyapp-6946649ccd-6d495$ kubectl scale --replicas=3 deployment myappdeployment.extensions/myapp scaled 灰度发布，更新与回滚12345678910111213141516171819202122232425262728293031323334353637383940414243$ kubectl set image deployment myapp myapp=ikubernetes/myapp:v2deployment.extensions/myapp image updated$ kubectl rollout status deployment myappWaiting for deployment &quot;myapp&quot; rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment &quot;myapp&quot; rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment &quot;myapp&quot; rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment &quot;myapp&quot; rollout to finish: 2 out of 3 new replicas have been updated...Waiting for deployment &quot;myapp&quot; rollout to finish: 2 out of 3 new replicas have been updated...Waiting for deployment &quot;myapp&quot; rollout to finish: 2 old replicas are pending termination...Waiting for deployment &quot;myapp&quot; rollout to finish: 1 old replicas are pending termination...Waiting for deployment &quot;myapp&quot; rollout to finish: 1 old replicas are pending termination...deployment &quot;myapp&quot; successfully rolled out/ # while true; do wget -O - -q myapp; sleep 1; doneHello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v1 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;Hello MyApp | Version: v2 | &lt;a href=&quot;hostname.html&quot;&gt;Pod Name&lt;/a&gt;$ kubectl rollout undo deployment myappdeployment.extensions/myapp 节点上相应iptables规则1# iptables -vnL -t nat 使集群外部可以访问myapp12345$ kubectl edit svc myapptype: ClusterIP --&gt; type: NodePort$ kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEmyapp NodePort 10.102.196.200 &lt;none&gt; 80:32074/TCP 14m PS: 如果节点宕机，还可以通过其它节点访问。外部做负载均衡器，例如keepalived，指向到每一个节点。Nginx或者haproxy，拥有后端realserver的健康度检查，并且需要配置HA高可用。]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[k8s配置secret拉取私有仓库镜像]]></title>
    <url>%2F2019%2F04%2F10%2Fk8s%E9%85%8D%E7%BD%AEsecret%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[https://kubernetes.io/docs 样例1234567891011# cat ~/.docker/config.json &#123; "auths": &#123; "harbor.station.com": &#123; "auth": "YWRtaW46SGFyYm9yMTIzNDU=" &#125; &#125;, "HttpHeaders": &#123; "User-Agent": "Docker-Client/18.06.1-ce (linux)" &#125;&#125; 这个时候我们虽然可以通过交互式登录，使用docker pull拉取镜像，但无法通过k8s创建Pod时拉取镜像。 生成密钥secret1# kubectl create secret docker-registry harbor --docker-server=x.x.x.x --docker-username=admin --docker-password=Harbor12345 --docker-email=xx@qq.com 1) harbor: 指定密钥的键名称，可自行定义 2）–docker-server：指定docker仓库地址 3）–docker-username：指定docker仓库帐号 4) –docker-password：指定docker仓库密码 5) –docker-email：指定邮件地址（选填）` 查看密钥可以看到当前除了默认的密钥, 还有我们刚才生成的. 另外要注意的是, 该密钥只能在对应namespace使用, 也就是这里的default, 如果需要用到其他namespace, 比如说test, 就需要在生成的时候指定参数 -n test。1234# kubectl get secretsNAME TYPE DATA AGEdefault-token-mzmtj kubernetes.io/service-account-token 3 22mharbor kubernetes.io/dockerconfigjson 1 22m YAML例子其中imagePullSecrets是声明拉取镜像时需要指定密钥, harbor必须和上面生成密钥的键名一致, 另外检查一下pod和密钥是否在同一个namespace, 之后k8s便可以拉取镜像。1234567891011121314151617apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: nginx-deploy namespace: harborspec: replicas: 3 template: metadata: labels: app: web_server spec: containers: - name: nginx image: harbor.station.com/library/nginx:latest imagePullSecrets: - name: harbor]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Harbor</tag>
      </tags>
  </entry>
</search>
